Parent p = new Child();
System.out.println(p.x); // 10 ‚Üí field accessed by reference type  Parent's field get printed or access here as 10
Fields get inherited depends on their access modifier  
Fields does not get overridden. *Imp*

### **1. Fields vs Methods**

* **Methods** in Java and C# can be **overridden** in a subclass.
* **Fields (variables)** **cannot be overridden**.

> In other words: fields are **hidden**, not overridden.

---

### **2. Field Hiding**

If a subclass defines a field with the **same name** as a field in its superclass, the subclass field **hides** the superclass field.

**Example in Java:**

```java
class Parent {
    public int x = 10;
}

class Child extends Parent {
    public int x = 20; // hides Parent's x
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        System.out.println(p.x); // 10 ‚Üí field accessed by reference type
        Child c = new Child();
        System.out.println(c.x); // 20 ‚Üí child field
    }
}
```

**Explanation:**

* `p.x` ‚Üí accesses **Parent‚Äôs field** because field access depends on **reference type**, not runtime object.
* `c.x` ‚Üí accesses **Child‚Äôs field**.

> Unlike methods, fields **do not use runtime polymorphism**.

---

### **3. In C#**

* Same rules as Java.
* Fields cannot be overridden; they can be **hidden using `new` keyword**.

**Example in C#:**

```csharp
class Parent {
    public int x = 10;
}

class Child : Parent {
    public new int x = 20; // hides Parent's x
}

class Program {
    static void Main() {
        Parent p = new Child();
        Console.WriteLine(p.x); // 10
        Child c = new Child();
        Console.WriteLine(c.x); // 20
    }
}
```

---

### ‚úÖ **Key Takeaways**

1. **Fields cannot be overridden**, only hidden.
2. Field access is determined by **reference type**, not object type.
3. Methods can be **overridden** and use **runtime polymorphism**.


### **1. Fields vs Methods**

* **Methods** in Java and C# can be **overridden** in a subclass.
* **Fields (variables)** **cannot be overridden**.

> In other words: fields are **hidden**, not overridden.

---

### **2. Field Hiding**

If a subclass defines a field with the **same name** as a field in its superclass, the subclass field **hides** the superclass field.

**Example in Java:**

```java
class Parent {
    public int x = 10;
}

class Child extends Parent {
    public int x = 20; // hides Parent's x
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        System.out.println(p.x); // 10 ‚Üí field accessed by reference type
        Child c = new Child();
        System.out.println(c.x); // 20 ‚Üí child field
    }
}
```

**Explanation:**

* `p.x` ‚Üí accesses **Parent‚Äôs field** because field access depends on **reference type**, not runtime object.
* `c.x` ‚Üí accesses **Child‚Äôs field**.

> Unlike methods, fields **do not use runtime polymorphism**.

---

### **3. In C#**

* Same rules as Java.
* Fields cannot be overridden; they can be **hidden using `new` keyword**.

**Example in C#:**

```csharp
class Parent {
    public int x = 10;
}

class Child : Parent {
    public new int x = 20; // hides Parent's x
}

class Program {
    static void Main() {
        Parent p = new Child();
        Console.WriteLine(p.x); // 10
        Child c = new Child();
        Console.WriteLine(c.x); // 20
    }
}
```

---

### ‚úÖ **Key Takeaways**

1. **Fields cannot be overridden**, only hidden.
2. Field access is determined by **reference type**, not object type.
3. Methods can be **overridden** and use **runtime polymorphism**.



### **Field Hiding vs Method Overriding**

| Feature                     | Field (Variable)                                          | Method                                                             |
| --------------------------- | --------------------------------------------------------- | ------------------------------------------------------------------ |
| **Can it be overridden?**   | ‚ùå No, it can only be **hidden**                           | ‚úÖ Yes, can be **overridden**                                       |
| **Access type**             | Determined by **reference type**                          | Determined by **runtime object type** (polymorphism)               |
| **Declaration in subclass** | `same name` hides parent field                            | `@Override` in Java / `override` in C#                             |
| **Runtime behavior**        | Uses field of **reference type**                          | Uses method of **actual object type**                              |
| **Example** (Java)          | `java<br>Parent p = new Child();<br>p.x ‚Üí Parent's x<br>` | `java<br>Parent p = new Child();<br>p.show() ‚Üí Child's show()<br>` |

---

### **Visual Diagram (Conceptual)**

```
Parent
+----------------+
| int x = 10     |   <--- Field
| void show() {} |   <--- Method
+----------------+
        ^
        |
Child
+----------------+
| int x = 20     |   <--- Hides Parent.x
| void show() {} |   <--- Overrides Parent.show()
+----------------+
```

**Behavior at runtime:**

```java
Parent p = new Child();
System.out.println(p.x);   // 10 ‚Üí field accessed by reference type
p.show();                   // Child's show() ‚Üí runtime polymorphism
```

---

üí° **Mnemonic:**

* **Fields ‚Üí hidden ‚Üí reference decides**
* **Methods ‚Üí overridden ‚Üí object decides**

---


## **1Ô∏è‚É£ Java Example**

```java
class Parent {
    public int x = 10;          // Field
    public void show() {        // Method
        System.out.println("Parent show");
    }
}

class Child extends Parent {
    public int x = 20;          // Hides Parent's x
    @Override
    public void show() {        // Overrides Parent's show
        System.out.println("Child show");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        Child c = new Child();

        System.out.println(p.x); // 10 ‚Üí field depends on reference type
        p.show();                // Child show ‚Üí method depends on object type

        System.out.println(c.x); // 20 ‚Üí field of child
        c.show();                // Child show ‚Üí method of child
    }
}
```

**Output (Java):**

```
10
Child show
20
Child show
```

---

## **2Ô∏è‚É£ C# Example**

```csharp
using System;

class Parent {
    public int x = 10;             // Field
    public virtual void Show() {   // Method
        Console.WriteLine("Parent Show");
    }
}

class Child : Parent {
    public new int x = 20;         // Hides Parent's x
    public override void Show() {  // Overrides Parent's Show
        Console.WriteLine("Child Show");
    }
}

class Program {
    static void Main() {
        Parent p = new Child();
        Child c = new Child();

        Console.WriteLine(p.x); // 10 ‚Üí field depends on reference type
        p.Show();               // Child Show ‚Üí method depends on object type

        Console.WriteLine(c.x); // 20 ‚Üí field of child
        c.Show();               // Child Show ‚Üí method of child
    }
}
```

**Output (C#):**

```
10
Child Show
20
Child Show
```

---

### ‚úÖ **Key Takeaways**

1. **Fields:**

   * Java: hides parent field if same name
   * C#: hides parent field using `new` keyword (optional but recommended)
   * Access depends on **reference type**.

2. **Methods:**

   * Java: `@Override` for overriding
   * C#: `override` for overriding, `virtual` in parent
   * Runtime behavior depends on **actual object** (polymorphism).

---

